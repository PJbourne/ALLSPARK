import cv2
import numpy as np
import math

def nada(x):
    pass

# ============================================================================
# CONFIGURA√á√ÉO GLOBAL
# ============================================================================

# Configura√ß√£o Geogr√°fica
LARGURA_KM = 5.0
CENTRO_LAT = -23.9600
CENTRO_LON = -46.3000

# Configura√ß√£o Arena Simulada
LARGURA_SIMULACAO = 200  
ALTURA_SIMULACAO = 200

# Cores para Detec√ß√£o
MIN_OLEO = np.array([0, 0, 0])
MAX_OLEO = np.array([180, 255, 80])
MIN_ALGA = np.array([0, 0, 20])
MAX_ALGA = np.array([180, 100, 130])

# Tamanhos para Detec√ß√£o
AREA_MINIMA_GERAL = 50
AREA_MAXIMA_ALGA = 450
AREA_MINIMA_OLEO = 451

# Valores para Calibra√ß√£o de √ìleo
VMAX_PRESET = 90
AREA_MIN_PRESET = 100
AREA_MAX_PRESET = 1500
RATIO_MIN_PRESET = 1.5

# ============================================================================
# FUN√á√ïES AUXILIARES
# ============================================================================

def encontrar_camera():
    for i in range(3):
        cap = cv2.VideoCapture(i)
        if cap.isOpened():
            ret, frame = cap.read()
            if ret:
                print(f"‚úÖ C√¢mera encontrada no √≠ndice {i}")
                cap.release()
                return i
            cap.release()
    return 0

def pixel_para_latlon(x, y, w_img, h_img):
    norm_x = (x - w_img / 2) / (w_img / 2)
    norm_y = (y - h_img / 2) / (h_img / 2)
    desloc_lat = (norm_y * (LARGURA_KM / 2)) / 111.11
    desloc_lon = (norm_x * (LARGURA_KM / 2)) / 111.11
    return CENTRO_LAT - desloc_lat, CENTRO_LON + desloc_lon

def converter_coord(x, y, w_img, h_img):
    lon = np.interp(x, [0, w_img], [-LARGURA_SIMULACAO, LARGURA_SIMULACAO])
    lat = np.interp(y, [0, h_img], [ALTURA_SIMULACAO, -ALTURA_SIMULACAO])
    return int(lon), int(lat)

def checar_se_cor_esta_no_intervalo(hsv_pixel, min_arr, max_arr):
    return (min_arr[0] <= hsv_pixel[0] <= max_arr[0] and
            min_arr[1] <= hsv_pixel[1] <= max_arr[1] and
            min_arr[2] <= hsv_pixel[2] <= max_arr[2])

# ============================================================================
# FUN√á√ïES DE PROCESSAMENTO - L√ìGICA ORIGINAL
# ============================================================================

def recortar_arena(frame):
    """Detecta e recorta a √°rea azul/verde (arena)"""
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    lower_ciano = np.array([30, 20, 50]) 
    upper_ciano = np.array([100, 255, 255])
    
    mask_chao = cv2.inRange(hsv, lower_ciano, upper_ciano)
    kernel = np.ones((5,5), np.uint8)
    mask_chao = cv2.morphologyEx(mask_chao, cv2.MORPH_OPEN, kernel)
    mask_chao = cv2.dilate(mask_chao, kernel, iterations=2)

    contornos, _ = cv2.findContours(mask_chao, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if len(contornos) > 0:
        maior_contorno = max(contornos, key=cv2.contourArea)
        if cv2.contourArea(maior_contorno) > 5000:
            x, y, w, h = cv2.boundingRect(maior_contorno)
            return frame[y:y+h, x:x+w], True
            
    return frame, False

def detectar_oleo_preciso(frame, v_max, area_min, area_max, ratio_min):
    """Detec√ß√£o PRECISA de √≥leo usando calibra√ß√£o"""
    h_img, w_img = frame.shape[:2]
    
    # Pr√©-processamento
    blurred = cv2.GaussianBlur(frame, (5, 5), 0)
    hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)

    # CORTE DE BORDAS
    mask_roi = np.zeros((h_img, w_img), dtype=np.uint8)
    cv2.rectangle(mask_roi, (50, 50), (w_img-50, h_img-50), 255, -1)

    # M√°scara de cor PARA √ìLEO
    lower = np.array([0, 0, 0])
    upper = np.array([180, 255, v_max])
    mask_cor = cv2.inRange(hsv, lower, upper)

    # Combina m√°scaras
    mask = cv2.bitwise_and(mask_cor, mask_roi)

    # Limpeza
    kernel = np.ones((3,3), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.dilate(mask, kernel, iterations=2) 

    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    deteccoes_oleo = []

    for cnt in contornos:
        area = cv2.contourArea(cnt)
        
        # Filtro de Tamanho
        if area < area_min or area > area_max: 
            continue

        # Filtro de Formato (Ratio)
        rect = cv2.minAreaRect(cnt)
        (cx, cy), (w, h), angle = rect
        
        lado_maior = max(w, h)
        lado_menor = min(w, h)
        if lado_menor == 0: 
            continue
            
        ratio_atual = lado_maior / lado_menor

        if ratio_atual < ratio_min: 
            continue

        # √ìLEO DETECTADO
        box = np.int32(cv2.boxPoints(rect))
        lat_real, lon_real = pixel_para_latlon(cx, cy, w_img, h_img)
        lon_sim, lat_sim = converter_coord(cx, cy, w_img, h_img)
        
        deteccoes_oleo.append({
            'centro': (cx, cy), 
            'lat_real': lat_real, 
            'lon_real': lon_real,
            'lat_sim': lat_sim,
            'lon_sim': lon_sim,
            'box': box,
            'area': area
        })

    return deteccoes_oleo, mask

def processar_todos_objetos(frame, v_max, area_min, area_max, ratio_min):
    """Processa NAVIOS, ALGAS e √ìLEO simultaneamente"""
    h, w, _ = frame.shape
    
    # 1. PRIMEIRO: Detectar √ìLEO com m√©todo PRECISO
    deteccoes_oleo, mask_oleo = detectar_oleo_preciso(frame, v_max, area_min, area_max, ratio_min)
    
    # 2. SEGUNDO: Detectar NAVIOS e ALGAS (objetos no fundo azul)
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower_bg = np.array([30, 20, 50]) 
    upper_bg = np.array([100, 255, 255])
    mask_bg = cv2.inRange(hsv, lower_bg, upper_bg)
    mask_objetos = cv2.bitwise_not(mask_bg)

    kernel = np.ones((3,3), np.uint8)
    mask_objetos = cv2.morphologyEx(mask_objetos, cv2.MORPH_OPEN, kernel)
    
    contornos, _ = cv2.findContours(mask_objetos, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    lista_navios = []
    qtd_algas = 0

    for cnt in contornos:
        area = cv2.contourArea(cnt)
        
        # Filtra ru√≠do e borda da imagem
        if area < AREA_MINIMA_GERAL or area > (w*h)*0.95: 
            continue 
        
        # Filtra borda preta
        x, y, w_box, h_box = cv2.boundingRect(cnt)
        if x <= 2 or y <= 2 or (x+w_box) >= w-2 or (y+h_box) >= h-2:
            continue

        centro = (int(x + w_box/2), int(y + h_box/2))
        lon_sim, lat_sim = converter_coord(centro[0], centro[1], w, h)
        lat_real, lon_real = pixel_para_latlon(centro[0], centro[1], w, h)

        # Pega a COR M√âDIA do objeto
        mask_single = np.zeros((h, w), dtype=np.uint8)
        cv2.drawContours(mask_single, [cnt], -1, 255, -1)
        media_hsv = cv2.mean(hsv, mask=mask_single)[:3]

        # L√ìGICA DE CLASSIFICA√á√ÉO: ALGA vs NAVIO
        # Verifica se √© ALGA
        if checar_se_cor_esta_no_intervalo(media_hsv, MIN_ALGA, MAX_ALGA) and area <= AREA_MAXIMA_ALGA:
            qtd_algas += 1
            cv2.circle(frame, centro, 5, (180, 180, 180), -1)
            cv2.putText(frame, "Alga", (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (180, 180, 180), 1)
        
        # Se n√£o √© Alga -> √â NAVIO
        else:
            lista_navios.append({
                'centro': centro, 
                'lat_real': lat_real, 
                'lon_real': lon_real,
                'lat_sim': lat_sim,
                'lon_sim': lon_sim
            })
            cv2.rectangle(frame, (x, y), (x+w_box, y+h_box), (0, 0, 255), 2)
            cv2.putText(frame, "Navio", (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    # 3. DESENHAR √ìLEO DETECTADO
    for oleo in deteccoes_oleo:
        cv2.drawContours(frame, [oleo['box']], 0, (0, 0, 255), 2)
        cv2.putText(frame, "OLEO", 
                   (oleo['box'][1][0], oleo['box'][1][1]-10), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    # 4. L√ìGICA DO POLUIDOR - CONECTAR √ìLEO COM NAVIO MAIS PR√ìXIMO
    poluidor_info = None
    
    for oleo in deteccoes_oleo:
        menor_dist = 999999
        navio_culpado = None
        
        for navio in lista_navios:
            d = math.dist(oleo['centro'], navio['centro'])
            if d < menor_dist:
                menor_dist = d
                navio_culpado = navio
        
        # Se encontrou um navio pr√≥ximo ao √≥leo
        if navio_culpado and menor_dist < 150:
            # Desenha linha conectando
            cv2.line(frame, oleo['centro'], navio_culpado['centro'], (0, 255, 255), 2)
            
            # Marca como poluidor
            poluidor_info = {
                'lat_real': navio_culpado['lat_real'],
                'lon_real': navio_culpado['lon_real'],
                'lat_sim': navio_culpado['lat_sim'],
                'lon_sim': navio_culpado['lon_sim'],
                'centro': navio_culpado['centro'],
                'oleo_proximo': f"Lat {oleo['lat_sim']} Lon {oleo['lon_sim']}",
                'distancia': int(menor_dist)
            }
            
            # Destaca navio poluidor
            x, y = navio_culpado['centro']
            cv2.circle(frame, (x, y), 10, (0, 255, 255), 3)
            cv2.putText(frame, "POLUIDOR!", (x-30, y-15), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)

    # 5. PREPARAR DADOS PARA PAINEL
    dados = {
        'navios': len(lista_navios),
        'algas': qtd_algas,
        'oleo': len(deteccoes_oleo),
        'poluidor': poluidor_info
    }
    
    return frame, dados, mask_oleo

# ============================================================================
# FUN√á√ïES DE INTERFACE
# ============================================================================

def desenhar_painel(img_display, dados_painel):
    """Desenha painel lateral com informa√ß√µes"""
    h, w, _ = img_display.shape
    largura_painel = 300
    tela_final = np.zeros((h, w + largura_painel, 3), dtype=np.uint8)
    tela_final[0:h, 0:w] = img_display 
    cv2.rectangle(tela_final, (w, 0), (w + largura_painel, h), (20, 20, 20), -1)
    
    x_txt = w + 20
    y_txt = 30
    fonte = cv2.FONT_HERSHEY_SIMPLEX
    
    cv2.putText(tela_final, "SISTEMA INTEGRADO", (x_txt, y_txt), fonte, 0.6, (0, 255, 255), 2)
    y_txt += 40
    cv2.putText(tela_final, f"Navios: {dados_painel['navios']}", (x_txt, y_txt), fonte, 0.5, (0, 255, 255), 1)
    y_txt += 25
    cv2.putText(tela_final, f"Algas: {dados_painel['algas']}", (x_txt, y_txt), fonte, 0.5, (200, 200, 200), 1)
    y_txt += 25
    cv2.putText(tela_final, f"Manchas Oleo: {dados_painel['oleo']}", (x_txt, y_txt), fonte, 0.5, (100, 100, 255), 1)
    
    y_txt += 40
    if dados_painel['poluidor']:
        cv2.putText(tela_final, "ALERTA: POLUIDOR!", (x_txt, y_txt), fonte, 0.6, (0, 0, 255), 2)
        p = dados_painel['poluidor']
        y_txt += 25
        cv2.putText(tela_final, f"Coords: {p['lat_sim']}, {p['lon_sim']}", (x_txt, y_txt), fonte, 0.5, (255, 255, 255), 1)
        y_txt += 20
        if p['oleo_proximo']:
            cv2.putText(tela_final, f"Oleo: {p['oleo_proximo']}", (x_txt, y_txt), fonte, 0.5, (255, 200, 0), 1)
    else:
        cv2.putText(tela_final, "OPERACAO NORMAL", (x_txt, y_txt), fonte, 0.5, (0, 255, 0), 2)

    return tela_final

# ============================================================================
# FUN√á√ÉO PRINCIPAL
# ============================================================================

def main():
    # ENCONTRAR C√ÇMERA AUTOMATICAMENTE
    camera_index = encontrar_camera()
    
    cap = cv2.VideoCapture(camera_index)
    cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.75)

    if not cap.isOpened():
        print("‚ùå Erro ao abrir c√¢mera.")
        return

    # Configura√ß√£o das janelas
    cv2.namedWindow("SISTEMA INTEGRADO")
    cv2.resizeWindow("SISTEMA INTEGRADO", 900, 600)
    cv2.namedWindow("MASCARA OLEO")
    cv2.resizeWindow("MASCARA OLEO", 400, 300)

    # Trackbars para calibra√ß√£o
    cv2.createTrackbar("V Max (Brilho)", "SISTEMA INTEGRADO", VMAX_PRESET, 255, nada)
    cv2.createTrackbar("Area Min", "SISTEMA INTEGRADO", AREA_MIN_PRESET, 1000, nada)
    cv2.createTrackbar("Area Max", "SISTEMA INTEGRADO", AREA_MAX_PRESET, 5000, nada)
    cv2.createTrackbar("Ratio Min", "SISTEMA INTEGRADO", int(RATIO_MIN_PRESET * 10), 100, nada)

    print("=== SISTEMA INTEGRADO ATIVADO ===")
    print("üéØ RECONHECE: Arena Azul ‚Ä¢ Navios ‚Ä¢ √ìleo ‚Ä¢ Algas")
    print("üìç SISTEMA DE COORDENADAS:")
    print(f"   Simula√ß√£o: ¬±{LARGURA_SIMULACAO}")
    print(f"   Real: Centro {CENTRO_LAT}, {CENTRO_LON}")
    print("\nTECLAS:")
    print(" [C] -> Calibra√ß√£o manual")
    print(" [Q] -> Sair")
    print("====================================")

    while True:
        ret, frame_original = cap.read()
        if not ret: 
            print("‚ùå Erro ao capturar frame.")
            break

        frame = cv2.resize(frame_original, (640, 480))

        # Leitura dos sliders
        v_max = cv2.getTrackbarPos("V Max (Brilho)", "SISTEMA INTEGRADO")
        area_min = cv2.getTrackbarPos("Area Min", "SISTEMA INTEGRADO")
        area_max = cv2.getTrackbarPos("Area Max", "SISTEMA INTEGRADO")
        ratio_min_slider = cv2.getTrackbarPos("Ratio Min", "SISTEMA INTEGRADO")
        ratio_min = ratio_min_slider / 10.0

        # Processa TUDO simultaneamente
        frame_recortado, arena_encontrada = recortar_arena(frame)
        
        if not arena_encontrada:
            # Se n√£o encontrou arena, mostra frame normal
            cv2.putText(frame, "ENQUADRE A ARENA AZUL...", (20, 50), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,255), 2)
            cv2.putText(frame, "SISTEMA INTEGRADO - AGUARDANDO ARENA", (10, 20), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
            
            info_txt = f"V:{v_max} | AreaMin:{area_min} | AreaMax:{area_max} | Ratio:{ratio_min:.1f}"
            cv2.putText(frame, info_txt, (10, frame.shape[0] - 10), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
            
            cv2.imshow("SISTEMA INTEGRADO", frame)
            cv2.imshow("MASCARA OLEO", np.zeros((300, 400), dtype=np.uint8))
        else:
            # Processa NAVIOS, ALGAS e √ìLEO
            resultado, dados, mask_oleo = processar_todos_objetos(
                frame_recortado, v_max, area_min, area_max, ratio_min
            )
            
            # Adiciona informa√ß√µes na tela
            cv2.putText(resultado, "SISTEMA INTEGRADO - MONITORANDO", (10, 20), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
            
            info_txt = f"V:{v_max} | AreaMin:{area_min} | AreaMax:{area_max} | Ratio:{ratio_min:.1f}"
            cv2.putText(resultado, info_txt, (10, resultado.shape[0] - 10), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
            
            imagem_final = desenhar_painel(resultado, dados)
            cv2.imshow("SISTEMA INTEGRADO", imagem_final)
            cv2.imshow("MASCARA OLEO", mask_oleo)

        key = cv2.waitKey(1) & 0xFF
        
        if key == ord('q'):
            break
        elif key == ord('c'):
            # Modo de calibra√ß√£o manual
            print("\n" + "="*40)
            print(" MODO CALIBRA√á√ÉO MANUAL")
            print(" Pressione ENTER vazio para manter valor atual.")
            print("="*40)
            
            try:
                raw = input(f"Novo V Max (Atual {v_max}): ")
                if raw: 
                    cv2.setTrackbarPos("V Max (Brilho)", "SISTEMA INTEGRADO", int(raw))

                raw = input(f"Nova Area Min (Atual {area_min}): ")
                if raw: 
                    cv2.setTrackbarPos("Area Min", "SISTEMA INTEGRADO", int(raw))

                raw = input(f"Nova Area Max (Atual {area_max}): ")
                if raw: 
                    cv2.setTrackbarPos("Area Max", "SISTEMA INTEGRADO", int(raw))

                raw = input(f"Novo Ratio Min (Atual {ratio_min}): ")
                if raw:
                    val_float = float(raw.replace(',', '.'))
                    val_slider = int(val_float * 10)
                    cv2.setTrackbarPos("Ratio Min", "SISTEMA INTEGRADO", val_slider)
                
                print("‚úÖ Valores atualizados!")
                
            except ValueError:
                print("‚ùå Valor inv√°lido!")

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
