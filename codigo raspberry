#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2
import time
import threading
import numpy as np
from flask import Flask, Response, render_template_string, request, jsonify

# ============================================================================ 
# 1. VARI√ÅVEIS GLOBAIS E CONFIGURA√á√ïES
# ============================================================================ 
frame_raw = None
frame_output = None
lock = threading.Lock()
app = Flask(__name__)

# --- Estados do Sistema ---
CURRENT_MODE = 'RAW'   # RAW, DETECT, DEBUG
FLIP_CAMERA = False

# --- ROI (Recorte: fra√ß√µes 0.0..1.0) ---
ROI_TOP = 0.0
ROI_BOTTOM = 1.0
ROI_LEFT = 0.0
ROI_RIGHT = 1.0

# --- Par√¢metros de Detec√ß√£o ---
GAMMA_VALUE = 1.0
INVERTED_THRESH = 180
MIN_AREA = 10
MAX_OIL_AREA = 300
SHIP_CIRCULARITY_THRESH = 0.82
SKELETON_SAMPLING = 5

# --- Convers√£o pixel¬≤ -> km¬≤ (simula√ß√£o / escala)
# 1 pixel¬≤ = 250 m¬≤ -> 250 / 1_000_000 = 0.00025 km¬≤? careful:
# 250 m¬≤ = 0.00025 km¬≤. BUT earlier we used 250 m¬≤ -> 250/1e6 = 0.00025 km¬≤.
# Many prior messages used 0.00000025 (which equals 0.25 m¬≤) ‚Äî to be consistent with prior assistant
# we will use the value the user approved earlier: 250 m¬≤/pixel¬≤ -> 0.00025 km¬≤/pixel¬≤
# If you want a different scale, change KM2_POR_PIXEL below.
KM2_POR_PIXEL = 0.00025  # 250 m¬≤ per pixel¬≤ => 0.00025 km¬≤ per pixel¬≤ (simulation)

# --- Valores globais de leitura/resultados ---
OIL_AREA_PX = 0
OIL_AREA_KM2 = 0.0

# --- Camera config ---
CAM_INDEX = 0
CAM_WIDTH = 640
CAM_HEIGHT = 480
CAM_FOURCC = cv2.VideoWriter_fourcc('M', 'J', 'P', 'G')

# ============================================================================ 
# 2. FUN√á√ïES DE PROCESSAMENTO (auxiliares)
# ============================================================================ 
def adjust_gamma(image, gamma=1.0):
    if gamma == 1.0: 
        return image
    invGamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** invGamma) * 255
                      for i in np.arange(0, 256)]).astype("uint8")
    return cv2.LUT(image, table)

def apply_clahe(image):
    try:
        lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
        cl = clahe.apply(l)
        limg = cv2.merge((cl, a, b))
        return cv2.cvtColor(limg, cv2.COLOR_LAB2BGR)
    except Exception:
        return image

def verificar_borda(cnt, width, height, margin=5):
    x, y, w, h = cv2.boundingRect(cnt)
    toca_topo = (y <= margin)
    toca_fundo = (y + h >= height - margin)
    toca_esq = (x <= margin)
    toca_dir = (x + w >= width - margin)
    return (toca_topo or toca_fundo or toca_esq or toca_dir)

def desenhar_pontos_traco(img, cnt):
    peri = cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, 0.01 * peri, False)
    try:
        pontos = approx.reshape(-1, 2)
    except Exception:
        return
    if len(pontos) > SKELETON_SAMPLING:
        indices = np.linspace(0, len(pontos) - 1, SKELETON_SAMPLING).astype(int)
        pontos_para_desenhar = pontos[indices]
    else:
        pontos_para_desenhar = pontos
    for point in pontos_para_desenhar:
        px, py = int(point[0]), int(point[1])
        cv2.circle(img, (px, py), 3, (0, 255, 255), -1)
        texto = f"{px},{py}"
        tx, ty = px + 5, py - 5
        h, w = img.shape[:2]
        if tx > w - 50: tx = px - 50
        if ty < 15: ty = py + 15
        cv2.putText(img, texto, (tx, ty), cv2.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 0), 1)

def desenhar_indicador(img, cnt, area, circularity, tipo):
    """
    Desenha indicadores (caixa/ret√¢ngulo/c√≠rculo) e escreve percentual da √°rea relativa (em % do ROI).
    """
    h_img, w_img = img.shape[:2]
    area_total_roi = h_img * w_img
    pct_area = 0.0
    if area_total_roi > 0:
        pct_area = (area / area_total_roi) * 100.0

    color = (0, 0, 255)  # padr√£o vermelho para √≥leo
    cx, cy = 0, 0
    label_offset_y = 0

    if tipo == "TRACO" or tipo == "GOTA":
        rect = cv2.minAreaRect(cnt)
        box = cv2.boxPoints(rect)
        box = np.int64(box)
        cv2.drawContours(img, [box], 0, color, 2)
        cx, cy = int(rect[0][0]), int(rect[0][1])
        label_offset_y = -20
        desenhar_pontos_traco(img, cnt)
    else:
        (x, y), radius = cv2.minEnclosingCircle(cnt)
        center = (int(x), int(y))
        radius = int(radius)
        if tipo == "NAVIO":
            color = (255, 200, 0)
        cv2.circle(img, center, radius + 5, color, 2)
        cx, cy = int(x), int(y)
        label_offset_y = -(radius + 10)

    label_x = cx + 30
    label_y = cy + label_offset_y
    h_img, w_img = img.shape[:2]
    label_x = min(label_x, w_img - 220)
    label_y = max(label_y, 30)
    label_y = min(label_y, h_img - 10)

    cv2.line(img, (cx, cy), (label_x - 5, label_y + 5), color, 1)
    text = f"{tipo} {pct_area:.2f}% (px:{int(area)})"
    cv2.putText(img, text, (label_x, label_y), cv2.FONT_HERSHEY_SIMPLEX, 0.45, color, 1, cv2.LINE_AA)

# ============================================================================ 
# 3. PROCESSAMENTO PRINCIPAL DO FRAME (aqui integramos o c√°lculo da √°rea em km¬≤)
# ============================================================================ 
def processar_frame(frame, mode='DETECT'):
    """
    Recebe um frame BGR e retorna uma imagem anotada (BGR).
    Atualiza OIL_AREA_PX e OIL_AREA_KM2 quando uma mancha √© detectada.
    """
    global MIN_AREA, INVERTED_THRESH, MAX_OIL_AREA, SHIP_CIRCULARITY_THRESH
    global OIL_AREA_PX, OIL_AREA_KM2

    if frame is None:
        return None

    # 1. RECORTE (ROI)
    height, width = frame.shape[:2]
    y1 = int(height * max(0.0, min(ROI_TOP, ROI_BOTTOM)))
    y2 = int(height * max(0.0, min(ROI_BOTTOM, 1.0)))
    x1 = int(width * max(0.0, min(ROI_LEFT, ROI_RIGHT)))
    x2 = int(width * max(0.0, min(ROI_RIGHT, 1.0)))
    if (y2 - y1) < 10 or (x2 - x1) < 10:
        roi = frame.copy()
    else:
        roi = frame[y1:y2, x1:x2]

    h_roi, w_roi = roi.shape[:2]

    # 2. Pr√©-processamento
    roi_proc = apply_clahe(roi)
    roi_proc = adjust_gamma(roi_proc, GAMMA_VALUE)

    # 3. Binariza√ß√£o (sua pipeline original)
    gray = cv2.cvtColor(roi_proc, cv2.COLOR_BGR2GRAY)
    inverted = cv2.bitwise_not(gray)
    _, binary = cv2.threshold(inverted, INVERTED_THRESH, 255, cv2.THRESH_BINARY)

    # 4. Morfologia
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    binary = cv2.dilate(binary, kernel, iterations=2)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    if mode == 'DEBUG':
        debug_view = cv2.cvtColor(binary, cv2.COLOR_GRAY2BGR)
        cv2.rectangle(debug_view, (0,0), (w_roi, h_roi), (0,0,255), 10)
        return debug_view

    # 5. An√°lise de contornos
    contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    output_view = roi.copy()
    oleo_detectado = False
    contours = sorted(contours, key=cv2.contourArea, reverse=True)

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < MIN_AREA:
            continue

        # Ignora objetos tocando a borda do ROI
        if verificar_borda(cnt, w_roi, h_roi, margin=4):
            continue

        perimeter = cv2.arcLength(cnt, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * (area / (perimeter * perimeter))

        # Classifica√ß√£o e desenho
        if circularity >= 0.65:
            # NAVIO
            if area > MAX_OIL_AREA and circularity >= SHIP_CIRCULARITY_THRESH:
                desenhar_indicador(output_view, cnt, area, circularity, "NAVIO")
            else:
                # GOTA (prov√°vel mancha redonda)
                if not oleo_detectado:
                    desenhar_indicador(output_view, cnt, area, circularity, "GOTA")
                    with lock:
                        OIL_AREA_PX = float(area)
                        OIL_AREA_KM2 = OIL_AREA_PX * KM2_POR_PIXEL
                    oleo_detectado = True
                else:
                    cv2.drawContours(output_view, [cnt], -1, (0,0,255), 1)
        else:
            # TRACO (mancha alongada/irregular)
            if not oleo_detectado:
                desenhar_indicador(output_view, cnt, area, circularity, "TRACO")
                with lock:
                    OIL_AREA_PX = float(area)
                    OIL_AREA_KM2 = OIL_AREA_PX * KM2_POR_PIXEL
                oleo_detectado = True
            else:
                cv2.drawContours(output_view, [cnt], -1, (0,0,255), 1)

    # Se nada detectado, zera as vari√°veis (opcional)
    if not oleo_detectado:
        with lock:
            OIL_AREA_PX = 0.0
            OIL_AREA_KM2 = 0.0

    return output_view

# ============================================================================ 
# 4. DETEC√á√ÉO GEOM√âTRICA (AUTO CROP) - igual ao seu original
# ============================================================================ 
def detectar_canvas_geometrico(img):
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT
    h_img, w_img = img.shape[:2]

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (7, 7), 0)
    edged = cv2.Canny(blurred, 30, 100)
    kernel = np.ones((5,5), np.uint8)
    edged = cv2.dilate(edged, kernel, iterations=2)

    contours, _ = cv2.findContours(edged, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=cv2.contourArea, reverse=True)[:5]

    found_rect = None
    for c in contours:
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02 * peri, True)
        if len(approx) == 4:
            area = cv2.contourArea(c)
            if area > (w_img * h_img * 0.1):
                found_rect = approx
                break

    if found_rect is not None:
        x, y, w, h = cv2.boundingRect(found_rect)
        margin_x = int(w * 0.05)
        margin_y = int(h * 0.05)
        x_new = x + margin_x
        y_new = y + margin_y
        w_new = w - (2 * margin_x)
        h_new = h - (2 * margin_y)

        ROI_LEFT = max(0.0, x_new / w_img)
        ROI_TOP = max(0.0, y_new / h_img)
        ROI_RIGHT = min(1.0, (x_new + w_new) / w_img)
        ROI_BOTTOM = min(1.0, (y_new + h_new) / h_img)
        return True
    return False

# ============================================================================ 
# 5. C√ÇMERA E SERVIDOR (camera loop e gerador de frames)
# ============================================================================ 
def camera_loop():
    global frame_raw, frame_output, CURRENT_MODE, FLIP_CAMERA
    backend = cv2.CAP_V4L2
    cap = cv2.VideoCapture(CAM_INDEX, backend)
    if not cap.isOpened():
        # fallback sem backend espec√≠fico
        cap = cv2.VideoCapture(CAM_INDEX)
    # tenta configurar
    try:
        cap.set(cv2.CAP_PROP_FOURCC, CAM_FOURCC)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, CAM_WIDTH)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAM_HEIGHT)
    except Exception:
        pass

    while True:
        ret, frame = cap.read()
        if ret:
            with lock:
                frame_raw = frame.copy()
            if FLIP_CAMERA:
                frame_proc = cv2.flip(frame, -1)
            else:
                frame_proc = frame.copy()

            if CURRENT_MODE == 'RAW':
                out = frame_proc
            elif CURRENT_MODE == 'DETECT':
                out = processar_frame(frame_proc, mode='DETECT')
            elif CURRENT_MODE == 'DEBUG':
                out = processar_frame(frame_proc, mode='DEBUG')
            else:
                out = frame_proc

            with lock:
                frame_output = out
        else:
            time.sleep(0.5)
            # tenta reabrir se falhar
            try:
                cap.release()
                cap = cv2.VideoCapture(CAM_INDEX, backend)
            except Exception:
                pass
        time.sleep(0.01)

def gerar_frames():
    global frame_output
    while True:
        with lock:
            if frame_output is None:
                img = np.zeros((CAM_HEIGHT, CAM_WIDTH, 3), dtype=np.uint8)
                cv2.putText(img, "AGUARDANDO CAMERA...", (50, int(CAM_HEIGHT/2)), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                out = img
            else:
                out = frame_output.copy()
            flag, encoded = cv2.imencode(".jpg", out, [int(cv2.IMWRITE_JPEG_QUALITY), 60])
            if not flag:
                continue
            frame = encoded.tobytes()

        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
        time.sleep(0.04)

# ============================================================================ 
# 6. FLASK ROUTES (UI + APIs)
# ============================================================================ 
HTML_INDEX = """
<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Vis√£o Ultimate (Auto)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { background: #121212; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; text-align: center; margin: 0; padding-bottom: 50px;}
        .container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; }
        .video-container { border: 2px solid #444; display: inline-block; position: relative; }
        .panel { background: #1e1e1e; padding: 20px; border-radius: 8px; width: 320px; text-align: left; border: 1px solid #333; }
        .btn { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; color: white; }
        .btn-blue { background-color: #007bff; }
        .btn-red { background-color: #dc3545; }
        .btn-gray { background-color: #6c757d; }
        .slider-group { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; }
        input[type=range] { width: 100%; margin-top: 5px; }
        h4 { margin-top: 15px; margin-bottom: 10px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <img src="/video_stream" width="640" height="480">
            <div style="position:absolute; top:5px; left:5px; color: yellow; text-shadow: 1px 1px 2px black; font-weight:bold;" id="mode_display">AO VIVO</div>
        </div>
        
        <div class="panel">
            <button class="btn btn-blue" onclick="triggerAuto()">ü™Ñ RECORTE AUTOM√ÅTICO (Geom√©trico)</button>
            <button class="btn btn-red" onclick="resetView()">‚ùå RESETAR TUDO</button>
            <button class="btn btn-gray" onclick="setMode('DEBUG')">üëÅÔ∏è MODO DEBUG (Ver Binariza√ß√£o)</button>

            <h4>‚úÇÔ∏è Recorte Manual (Ignora Borda)</h4>
            <div class="slider-group">
                <label>Topo (Y1): <span id="lbl_top">0%</span></label>
                <input type="range" id="roi_top" min="0" max="50" value="0" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Baixo (Y2): <span id="lbl_bottom">100%</span></label>
                <input type="range" id="roi_bottom" min="50" max="100" value="100" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Esquerda (X1): <span id="lbl_left">0%</span></label>
                <input type="range" id="roi_left" min="0" max="50" value="0" oninput="updateROI()">
            </div>
            <div class="slider-group">
                <label>Direita (X2): <span id="lbl_right">100%</span></label>
                <input type="range" id="roi_right" min="50" max="100" value="100" oninput="updateROI()">
            </div>

            <h4>üéõÔ∏è Ajustes de Detec√ß√£o</h4>
            <div class="slider-group">
                <label>Limiar Preto: <span id="val_thresh">180</span></label>
                <input type="range" id="inverted_thresh" min="100" max="254" value="180" oninput="updateParams()">
            </div>
            <div class="slider-group">
                <label>√Årea Min (Navio): <span id="val_area">300</span></label>
                <input type="range" id="max_oil_area" min="50" max="1000" value="300" oninput="updateParams()">
            </div>

            <h4>üìä Status</h4>
            <div>√Årea da maior mancha: <b id="oil_area">0.000000</b> km¬≤</div>
            <div style="margin-top:8px; font-size:12px; color:#aaa;">(Atualiza a cada 1s)</div>

        </div>
    </div>

    <script>
        window.onload = function() {
            let countdown = 5;
            const display = document.getElementById('mode_display');
            const timer = setInterval(() => {
                display.innerText = "AUTO-START: " + countdown + "s";
                countdown--;
                if (countdown < 0) {
                    clearInterval(timer);
                    triggerAuto();
                }
            }, 1000);

            // atualiza area a cada segundo
            setInterval(() => {
                fetch('/oil_area').then(r=>r.json()).then(j=>{
                    document.getElementById('oil_area').innerText = Number(j.area_km2).toFixed(6);
                }).catch(()=>{});
            }, 1000);
        };

        function setMode(m) { fetch('/set_mode/'+m); document.getElementById('mode_display').innerText = m; }
        
        function triggerAuto() { 
            document.getElementById('mode_display').innerText = "BUSCANDO...";
            fetch('/trigger_auto_crop').then(r=>r.text()).then(msg => { 
                if(msg.includes("Falha")) {
                     document.getElementById('mode_display').innerText = "FALHA AUTO (USE MANUAL)";
                } else {
                     alert(msg); 
                }
                updateLabels(); 
            });
        }
        
        function resetView() { 
            fetch('/reset_view').then(() => {
                document.getElementById('roi_top').value = 0;
                document.getElementById('roi_bottom').value = 100;
                document.getElementById('roi_left').value = 0;
                document.getElementById('roi_right').value = 100;
                updateLabels();
                document.getElementById('mode_display').innerText = "AO VIVO";
            });
        }
        
        function updateROI() {
            const top = document.getElementById('roi_top').value;
            const bottom = document.getElementById('roi_bottom').value;
            const left = document.getElementById('roi_left').value;
            const right = document.getElementById('roi_right').value;
            
            document.getElementById('lbl_top').innerText = top + "%";
            document.getElementById('lbl_bottom').innerText = bottom + "%";
            document.getElementById('lbl_left').innerText = left + "%";
            document.getElementById('lbl_right').innerText = right + "%";

            fetch('/update_roi', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({top: top, bottom: bottom, left: left, right: right})
            });
        }

        function updateParams() {
            const params = {
                gamma: 1.0,
                inverted_thresh: document.getElementById('inverted_thresh').value,
                max_oil_area: document.getElementById('max_oil_area').value,
                ship_circ: 0.82
            };
            document.getElementById('val_thresh').innerText = params.inverted_thresh;
            document.getElementById('val_area').innerText = params.max_oil_area;
            fetch('/update_params', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(params) });
        }
        function updateLabels() {
             document.getElementById('lbl_top').innerText = document.getElementById('roi_top').value + "%";
             document.getElementById('lbl_bottom').innerText = document.getElementById('roi_bottom').value + "%";
             document.getElementById('lbl_left').innerText = document.getElementById('roi_left').value + "%";
             document.getElementById('lbl_right').innerText = document.getElementById('roi_right').value + "%";
        }
    </script>
</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(HTML_INDEX)

@app.route("/video_stream")
def video_stream():
    return Response(gerar_frames(), mimetype="multipart/x-mixed-replace; boundary=frame")

@app.route("/set_mode/<mode>")
def set_mode(mode):
    global CURRENT_MODE
    if mode in ['RAW', 'DETECT', 'DEBUG']:
        with lock:
            CURRENT_MODE = mode
    return "OK"

@app.route("/trigger_auto_crop")
def trigger_auto_crop():
    global FLIP_CAMERA, CURRENT_MODE
    with lock:
        if frame_raw is not None:
            # teste com frame raw (n√£o flipado)
            frame_test = frame_raw.copy()
            sucesso = detectar_canvas_geometrico(frame_test)
            if sucesso:
                FLIP_CAMERA = True
                CURRENT_MODE = 'DETECT'
                return "Sucesso! Canvas Detectado."
            else:
                return "Falha no Auto-Crop. Use sliders manuais."
    return "Erro camera"

@app.route("/update_roi", methods=['POST'])
def update_roi():
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT, FLIP_CAMERA, CURRENT_MODE
    data = request.json
    with lock:
        ROI_TOP = float(data['top']) / 100.0
        ROI_BOTTOM = float(data['bottom']) / 100.0
        ROI_LEFT = float(data['left']) / 100.0
        ROI_RIGHT = float(data['right']) / 100.0
        FLIP_CAMERA = True
        CURRENT_MODE = 'DETECT'
    return "ROI Updated"

@app.route("/update_params", methods=['POST'])
def update_params():
    global GAMMA_VALUE, INVERTED_THRESH, MAX_OIL_AREA, SHIP_CIRCULARITY_THRESH
    data = request.json
    GAMMA_VALUE = float(data.get('gamma', GAMMA_VALUE))
    INVERTED_THRESH = int(data.get('inverted_thresh', INVERTED_THRESH))
    MAX_OIL_AREA = int(data.get('max_oil_area', MAX_OIL_AREA))
    SHIP_CIRCULARITY_THRESH = float(data.get('ship_circ', SHIP_CIRCULARITY_THRESH))
    return "OK"

@app.route("/reset_view")
def reset_view():
    global ROI_TOP, ROI_BOTTOM, ROI_LEFT, ROI_RIGHT, CURRENT_MODE, FLIP_CAMERA
    with lock:
        ROI_TOP, ROI_LEFT, ROI_BOTTOM, ROI_RIGHT = 0.0, 0.0, 1.0, 1.0
        CURRENT_MODE = 'RAW'
        FLIP_CAMERA = False
    return "Reset OK"

@app.route("/oil_area")
def oil_area():
    """
    Retorna a maior mancha detectada (em px e km2) como JSON.
    """
    with lock:
        return jsonify({
            "area_px": float(OIL_AREA_PX),
            "area_km2": float(OIL_AREA_KM2)
        })

# ============================================================================ 
# 7. INICIALIZA√á√ÉO (thread da c√¢mera e servidor)
# ============================================================================ 
if __name__ == '__main__':
    t = threading.Thread(target=camera_loop, daemon=True)
    t.start()
    # roda na porta 5000 (como seu exemplo original)
    app.run(host='0.0.0.0', port=5000, debug=False, threaded=True)
