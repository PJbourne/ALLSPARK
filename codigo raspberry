import cv2
import numpy as np
import tkinter as tk
from tkinter import filedialog
import math
import csv
import os
import random
import platform
import sys
import time

# ============================================================================
# CONFIGURAÇÕES E BANCO DE DADOS
# ============================================================================

ARQUIVO_CSV = "Cores e Figuras.xlsx - Página1.csv"

# --- PARÂMETROS DE GEOLOCALIZAÇÃO ---
LARGURA_SIMULACAO = 200
ALTURA_SIMULACAO = 200

# --- CONFIGURAÇÃO DE CORES (HSV) ---
MIN_OLEO = np.array([0, 0, 0])
MAX_OLEO = np.array([180, 255, 60])
MIN_ALGA = np.array([0, 0, 20])
MAX_ALGA = np.array([180, 100, 150])

# --- PARÂMETROS DE ÁREA ---
AREA_MINIMA_GERAL = 10
AREA_MAXIMA_ALGA = 150
AREA_MINIMA_OLEO = 151

# --- PARÂMETROS DE DETECÇÃO DE POLUIDOR ---
RAIO_POLUIDOR_MAX = 150

def nada(x): pass

# ============================================================================
# 1. MÓDULO DE IDENTIFICAÇÃO (MMSI via CSV)
# ============================================================================

def carregar_banco_dados_navios(caminho_csv):
    db_navios = []
    if not os.path.exists(caminho_csv):
        print(f"AVISO: Arquivo '{caminho_csv}' não encontrado. A identificação MMSI não funcionará.")
        return []

    try:
        with open(caminho_csv, 'r', encoding='utf-8-sig') as f:
            leitor = csv.reader(f)
            try:
                next(leitor)
            except StopIteration:
                pass
            for linha in leitor:
                if len(linha) >= 6:
                    mmsi = linha[1]
                    try:
                        r = int(float(linha[3]))
                        g = int(float(linha[4]))
                        b = int(float(linha[5]))
                        db_navios.append({'mmsi': mmsi, 'rgb': (r, g, b)})
                    except ValueError:
                        continue
        print(f"Sucesso: {len(db_navios)} navios carregados do banco de dados.")
        return db_navios
    except Exception as e:
        print(f"Erro ao ler CSV: {e}")
        return []

def identificar_mmsi(cor_bgr_media, db_navios):
    if not db_navios:
        return "Desconhecido", 999

    b, g, r = [int(v) for v in cor_bgr_media]
    menor_distancia = float('inf')
    mmsi_encontrado = "Desconhecido"

    for navio in db_navios:
        r_db, g_db, b_db = navio['rgb']
        dist = math.sqrt((r - r_db)**2 + (g - g_db)**2 + (b - b_db)**2)

        if dist < menor_distancia:
            menor_distancia = dist
            mmsi_encontrado = navio['mmsi']

    if menor_distancia > 50:
        return "Não listado", menor_distancia

    return mmsi_encontrado, menor_distancia

# ============================================================================
# 2. UTILITÁRIOS E PROCESSAMENTO
# ============================================================================

def converter_coord(x, y, w_img, h_img):
    lon = np.interp(x, [0, w_img], [-LARGURA_SIMULACAO, LARGURA_SIMULACAO])
    lat = np.interp(y, [0, h_img], [ALTURA_SIMULACAO, -ALTURA_SIMULACAO])
    return int(lat), int(lon)

def checar_se_cor_esta_no_intervalo(hsv_pixel, min_arr, max_arr):
    return (min_arr[0] <= hsv_pixel[0] <= max_arr[0] and
            min_arr[1] <= hsv_pixel[1] <= max_arr[1] and
            min_arr[2] <= hsv_pixel[2] <= max_arr[2])

def classificar_objeto(media_hsv, area):
    if checar_se_cor_esta_no_intervalo(media_hsv, MIN_OLEO, MAX_OLEO) and area >= AREA_MINIMA_OLEO:
        return "OLEO", (0, 0, 0)
    elif checar_se_cor_esta_no_intervalo(media_hsv, MIN_ALGA, MAX_ALGA) and area <= AREA_MAXIMA_ALGA:
        return "ALGA", (180, 180, 180)
    else:
        return "NAVIO", (0, 0, 255)

def recortar_arena(frame, calib):
    # MODO MANUAL: Retorna o frame inteiro
    return frame, True

def desenhar_hud(img, dados):
    h, w = img.shape[:2]
    w_hud = 280
    tela = np.zeros((h, w + w_hud, 3), dtype=np.uint8)
    tela[0:h, 0:w] = img

    cv2.rectangle(tela, (w, 0), (w+w_hud, h), (30, 30, 30), -1)
    x, y, f = w + 20, 40, cv2.FONT_HERSHEY_SIMPLEX

    cv2.putText(tela, "PROJETO CUBESAT", (x, y), f, 0.6, (0, 255, 255), 2)
    y += 40

    cv2.putText(tela, f"Navios: {len(dados['lista_navios'])}", (x, y), f, 0.5, (0, 255, 0), 1)
    y += 25
    for navio in dados['lista_navios'][:5]:
        mmsi = navio['mmsi']
        cv2.putText(tela, f"> {mmsi}", (x, y), f, 0.4, (200, 255, 200), 1)
        y += 20

    y += 10
    cv2.putText(tela, f"Oleo: {dados['oleo']}", (x, y), f, 0.5, (0, 0, 255), 1)

    y += 40
    if dados['poluidor']:
        p = dados['poluidor']
        cv2.rectangle(tela, (x-5, y-25), (w+w_hud-10, y+45), (0, 0, 150), -1)
        cv2.putText(tela, "ALERTA: POLUIDOR", (x, y), f, 0.5, (255, 255, 255), 2)
        cv2.putText(tela, f"MMSI: {p['mmsi']}", (x, y+20), f, 0.5, (255, 255, 0), 2)
    else:
        cv2.putText(tela, "Status: SEGURO", (x, y), f, 0.6, (0, 255, 0), 1)

    return tela

def main():
    db_navios = carregar_banco_dados_navios(ARQUIVO_CSV)
    
    # --- CONFIGURAÇÃO RIGOROSA DE CÂMERA ---
    cap = None
    fonte = 0
    
    sistema_os = platform.system()
    print(f"--- Sistema Detectado: {sistema_os} ---")

    if sistema_os == "Linux":
        print("Iniciando modo Raspberry Pi (V4L2)...")
        # No Linux, somos rigorosos: só roda se abrir o V4L2 corretamente
        try:
            cap = cv2.VideoCapture(fonte, cv2.CAP_V4L2)
            
            # 1. Verifica se o objeto abriu
            if not cap.isOpened():
                print("ERRO CRÍTICO (Raspberry): Câmera não detectada na porta 0.")
                print("O código será encerrado pois a câmera é obrigatória.")
                sys.exit() # Encerra o script
            
            # 2. Verifica se está recebendo frames reais
            print("Verificando fluxo de dados da câmera...")
            ret_teste, _ = cap.read()
            if not ret_teste:
                print("ERRO CRÍTICO (Raspberry): Câmera detectada, mas falhou ao enviar imagem (Frame vazio).")
                print("Verifique o cabo flat ou USB.")
                sys.exit() # Encerra o script
                
            print(">>> SUCESSO: Câmera Raspberry Pi Operacional.")
            
        except Exception as e:
            print(f"ERRO DE EXCEÇÃO: {e}")
            sys.exit()

    else:
        # Modo Windows (Mantém a compatibilidade para seus testes no PC)
        print("Iniciando modo Windows (DirectShow)...")
        cap = cv2.VideoCapture(fonte, cv2.CAP_DSHOW)
        if not cap.isOpened():
            cap = cv2.VideoCapture(fonte) # Fallback genérico
            
        if not cap.isOpened():
            print("ERRO: Nenhuma câmera encontrada no Windows.")
            sys.exit()

    # Configuração de Resolução (Comum aos dois)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)

    # --- INÍCIO DO LOOP ---
    cv2.namedWindow("CALIBRACAO")
    cv2.createTrackbar("H Min", "CALIBRACAO", 39, 179, nada)
    cv2.createTrackbar("S Min", "CALIBRACAO", 0, 255, nada)
    cv2.createTrackbar("V Min", "CALIBRACAO", 0, 255, nada)
    cv2.createTrackbar("H Max", "CALIBRACAO", 97, 179, nada)
    cv2.createTrackbar("S Max", "CALIBRACAO", 132, 255, nada)
    cv2.createTrackbar("V Max", "CALIBRACAO", 146, 255, nada)

    print("--- SISTEMA MONITORAMENTO INICIADO ---")

    while True:
        ret, frame = cap.read()
        if not ret:
            print("Aviso: Perda de sinal da câmera.")
            break

        frame = cv2.resize(frame, (800, 600))
        
        calib = {
            'h_min': cv2.getTrackbarPos("H Min", "CALIBRACAO"), 's_min': cv2.getTrackbarPos("S Min", "CALIBRACAO"),
            'v_min': cv2.getTrackbarPos("V Min", "CALIBRACAO"), 'h_max': cv2.getTrackbarPos("H Max", "CALIBRACAO"),
            's_max': cv2.getTrackbarPos("S Max", "CALIBRACAO"), 'v_max': cv2.getTrackbarPos("V Max", "CALIBRACAO")
        }

        # Modo manual (sem corte)
        arena, ok = recortar_arena(frame, calib)
        if not ok:
            cv2.imshow("Projeto CubeSat Monitor", frame)
            if cv2.waitKey(1) == ord('q'): break
            continue

        h_arena, w_arena = arena.shape[:2]
        area_total_km2 = (LARGURA_SIMULACAO * 2) * (ALTURA_SIMULACAO * 2)
        area_total_px = w_arena * h_arena
        km2_por_pixel = area_total_km2 / area_total_px if area_total_px > 0 else 0

        hsv_arena = cv2.cvtColor(arena, cv2.COLOR_BGR2HSV)
        
        lower_w = np.array([calib['h_min'], calib['s_min'], calib['v_min']])
        upper_w = np.array([calib['h_max'], calib['s_max'], calib['v_max']])
        mask_obj = cv2.bitwise_not(cv2.inRange(hsv_arena, lower_w, upper_w))

        kernel_obj = np.ones((3,3), np.uint8)
        mask_obj = cv2.morphologyEx(mask_obj, cv2.MORPH_OPEN, kernel_obj, iterations=1)
        mask_obj = cv2.morphologyEx(mask_obj, cv2.MORPH_CLOSE, kernel_obj, iterations=2)

        contornos, _ = cv2.findContours(mask_obj, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        objs_navio = []
        objs_oleo = []
        qtd_algas = 0

        for cnt in contornos:
            area_px = cv2.contourArea(cnt)
            if area_px < AREA_MINIMA_GERAL: continue
            if area_px > (w_arena * h_arena) * 0.95: continue

            x, y, w, h = cv2.boundingRect(cnt)
            centro = (int(x + w/2), int(y + h/2))
            lat, lon = converter_coord(centro[0], centro[1], w_arena, h_arena)

            mask_i = np.zeros((h_arena, w_arena), dtype=np.uint8)
            cv2.drawContours(mask_i, [cnt], -1, 255, -1)

            media_hsv = cv2.mean(hsv_arena, mask=mask_i)[:3]
            media_bgr = cv2.mean(arena, mask=mask_i)[:3]

            label, cor = classificar_objeto(media_hsv, area_px)

            if label == "OLEO":
                objs_oleo.append({'pos': centro, 'lat': lat, 'lon': lon})
                cv2.drawContours(arena, [cnt], -1, (0,0,255), 2)
                
                area_real_km2 = area_px * km2_por_pixel
                porcentagem_erro = random.uniform(0.01, 0.10)
                sinal_erro = random.choice([-1, 1])
                area_com_erro = area_real_km2 * (1 + (sinal_erro * porcentagem_erro))
                
                texto_area = f"{area_com_erro:.2f} km2"
                cv2.putText(arena, texto_area, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
                cv2.putText(arena, "OLEO", (x, y + h + 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)

            elif label == "ALGA":
                qtd_algas += 1
                cv2.circle(arena, centro, 5, cor, -1)

            elif label == "NAVIO":
                mmsi, conf = identificar_mmsi(media_bgr, db_navios)
                objs_navio.append({'pos': centro, 'lat': lat, 'lon': lon, 'mmsi': mmsi})
                cv2.rectangle(arena, (x,y), (x+w, y+h), cor, 2)
                if w > 10:
                    cv2.putText(arena, str(mmsi), (x, y-15), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,255,255), 1)
                    cv2.putText(arena, "NAVIO", (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, cor, 1)

        poluidor = None
        for oleo in objs_oleo:
            menor_d = float('inf')
            culpado = None
            for navio in objs_navio:
                d = math.dist(oleo['pos'], navio['pos'])
                if d < menor_d:
                    menor_d = d
                    culpado = navio
            if culpado and menor_d < RAIO_POLUIDOR_MAX:
                cv2.line(arena, oleo['pos'], culpado['pos'], (0, 255, 255), 2)
                poluidor = culpado

        dados = {
            'lista_navios': objs_navio,
            'navios': len(objs_navio),
            'algas': qtd_algas,
            'oleo': len(objs_oleo),
            'poluidor': poluidor
        }

        frame_final = desenhar_hud(arena, dados)
        cv2.imshow("Projeto CubeSat Monitor", frame_final)

        if cv2.waitKey(1) == ord('q'): break

    if cap: cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
